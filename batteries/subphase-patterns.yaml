# Subphase patterns define what tasks get created inside container phases.
# Ships with batteries. Projects customize in .kata/subphase-patterns.yaml.
# Templates reference patterns by name via `subphase_pattern: "impl-verify"`.
#
# Steps support optional `instruction` (template with placeholders) and `agent`
# (provider/prompt/gate config — same schema as template phase step agents).

subphase_patterns:
  impl-test-verify:
    description: "Implement, test process gates, then verify against real services"
    steps:
      - id_suffix: impl
        title_template: "IMPL - {task_summary}"
        todo_template: "Implement {task_summary}"
        active_form: "Implementing {phase_name}"
        labels: [impl]
      - id_suffix: test
        title_template: "TEST - {phase_name}"
        todo_template: "Test {phase_name} implementation"
        active_form: "Testing {phase_name}"
        labels: [test]
        depends_on_previous: true
        instruction: "Run verify-phase for {phase_name}: kata verify-phase {phase_label} --issue={issue}"
      - id_suffix: verify
        title_template: "VERIFY - {phase_name}"
        todo_template: "Verify {phase_name} against real services"
        active_form: "Verifying {phase_name}"
        labels: [verify, agent-verify]
        depends_on_previous: true
        instruction: |
          Spawn a FRESH verification agent to execute the spec's Verification Plan.
          The agent should have NO knowledge of the implementation — only the VP steps.

          ## Verification Tools

          The agent has access to these tools for real-system verification:

          **Dev Server:** Start the project's dev server (see `dev_server_command` in wm.yaml
          or the VP steps). Wait for the health endpoint before proceeding.

          **API Testing:** Use `curl`, `httpie`, or direct HTTP requests via Bash to hit
          real API endpoints. Check status codes, response bodies, headers.

          **Browser Testing:** For UI features, use the browser tool (WebFetch) or describe
          navigation steps. Check that pages render, forms submit, and UI state updates.

          **CLI Testing:** Run CLI commands and verify stdout/stderr output matches expectations.

          **Database/State Checks:** Query real data stores to verify side effects
          (records created, state changed, files written).

          ## Verification Plan

          {verification_plan}

  # Legacy pattern — kept for backwards compatibility with existing project templates
  impl-verify:
    description: "Implement then verify each spec phase"
    steps:
      - id_suffix: impl
        title_template: "IMPL - {task_summary}"
        todo_template: "Implement {task_summary}"
        active_form: "Implementing {phase_name}"
        labels: [impl]
      - id_suffix: verify
        title_template: "VERIFY - {phase_name}"
        todo_template: "Verify {phase_name} implementation"
        active_form: "Verifying {phase_name}"
        labels: [verify]
        depends_on_previous: true
        instruction: "Run verify-phase for {phase_name}: kata verify-phase {phase_label} --issue={issue}"
