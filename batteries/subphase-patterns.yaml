# Subphase patterns define what tasks get created inside container phases.
# Ships with batteries. Projects customize in .kata/subphase-patterns.yaml.
# Templates reference patterns by name via `subphase_pattern: "impl-verify"`.
#
# Steps support optional `instruction` (template with placeholders) and `agent`
# (provider/prompt/gate config — same schema as template phase step agents).

subphase_patterns:
  impl-test-verify:
    description: "Implement, test process gates, then verify against real services"
    steps:
      - id_suffix: impl
        title_template: "IMPL - {task_summary}"
        todo_template: "Implement {task_summary}"
        active_form: "Implementing {phase_name}"
        labels: [impl]
        instruction: |
          ⛔ DO NOT implement this phase yourself. SPAWN an impl-agent.

          Task(subagent_type="impl-agent", prompt="
            SPEC PHASE: {phase_name}
            TASK: {task_summary}
            Do NOT complete tasks — return results to orchestrator.
          ")

          After the agent returns, verify its work:
          ```bash
          git diff --stat   # Review what changed
          git status        # Confirm changes exist
          ```

          Then: Mark this task completed via TaskUpdate
      - id_suffix: test
        title_template: "TEST - {phase_name}"
        todo_template: "Test {phase_name} implementation"
        active_form: "Testing {phase_name}"
        labels: [test]
        depends_on_previous: true
        instruction: |
          If the spec phase has `test_cases:` and tests don't exist yet, spawn test-agent first:
          Task(subagent_type="test-agent", prompt="
            SPEC PHASE: {phase_name}
            Write tests for any spec test_cases not yet covered.
            Return: test files written, pass/fail results.
          ")

          Then run the process gate:
          kata check-phase {phase_label} --issue={issue}
      - id_suffix: verify
        title_template: "VERIFY - {phase_name}"
        todo_template: "Verify {phase_name} against real services"
        active_form: "Verifying {phase_name}"
        labels: [verify, agent-verify]
        depends_on_previous: true
        instruction: |
          Spawn a FRESH verification agent to execute the spec's Verification Plan.
          The agent should have NO knowledge of the implementation — only the VP steps.

          Before executing, read the project's verification tools config:
          - `.kata/verification-tools.md` (or `.claude/workflows/verification-tools.md`)
          This file has the project's dev server command, API base URL, auth setup,
          database access, and key endpoints. Read it FIRST.

          ## Verification Plan

          {verification_plan}

  impl-test:
    description: "Implement then run process gates (build, typecheck, tests)"
    steps:
      - id_suffix: impl
        title_template: "IMPL - {task_summary}"
        todo_template: "Implement {task_summary}"
        active_form: "Implementing {phase_name}"
        labels: [impl]
        instruction: |
          ⛔ DO NOT implement this phase yourself. SPAWN an impl-agent.

          Task(subagent_type="impl-agent", prompt="
            SPEC PHASE: {phase_name}
            TASK: {task_summary}
            Do NOT complete tasks — return results to orchestrator.
          ")

          After the agent returns, verify its work:
          ```bash
          git diff --stat   # Review what changed
          git status        # Confirm changes exist
          ```

          Then: Mark this task completed via TaskUpdate
      - id_suffix: test
        title_template: "TEST - {phase_name}"
        todo_template: "Test {phase_name} implementation"
        active_form: "Testing {phase_name}"
        labels: [test]
        depends_on_previous: true
        instruction: |
          If the spec phase has `test_cases:` and tests don't exist yet, spawn test-agent first:
          Task(subagent_type="test-agent", prompt="
            SPEC PHASE: {phase_name}
            Write tests for any spec test_cases not yet covered.
            Return: test files written, pass/fail results.
          ")

          Then run the process gate:
          kata check-phase {phase_label} --issue={issue}

  impl-test-review:
    description: "Implement, run process gates, then lightweight code review via provider"
    steps:
      - id_suffix: impl
        title_template: "IMPL - {task_summary}"
        todo_template: "Implement {task_summary}"
        active_form: "Implementing {phase_name}"
        labels: [impl]
        instruction: |
          ⛔ DO NOT implement this phase yourself. SPAWN an impl-agent.

          Task(subagent_type="impl-agent", prompt="
            SPEC PHASE: {phase_name}
            TASK: {task_summary}
            Do NOT complete tasks — return results to orchestrator.
          ")

          After the agent returns, verify its work:
          ```bash
          git diff --stat   # Review what changed
          git status        # Confirm changes exist
          ```

          Then: Mark this task completed via TaskUpdate
      - id_suffix: test
        title_template: "TEST - {phase_name}"
        todo_template: "Test {phase_name} implementation"
        active_form: "Testing {phase_name}"
        labels: [test]
        depends_on_previous: true
        instruction: |
          If the spec phase has `test_cases:` and tests don't exist yet, spawn test-agent first:
          Task(subagent_type="test-agent", prompt="
            SPEC PHASE: {phase_name}
            Write tests for any spec test_cases not yet covered.
            Return: test files written, pass/fail results.
          ")

          Then run the process gate:
          kata check-phase {phase_label} --issue={issue}
      - id_suffix: review
        title_template: "REVIEW - {phase_name}"
        todo_template: "Review {phase_name} changes"
        active_form: "Reviewing {phase_name}"
        labels: [review]
        depends_on_previous: true
        instruction: |
          Run all reviewers sequentially and print each result:

          1. Spawn review-agent:
          Task(subagent_type="review-agent", prompt="
            Review the changes for {phase_name}.
            Check the diff against the spec for correctness, edge cases, and quality.
            Return: review verdict (APPROVE / REQUEST CHANGES) with file:line issues.
          ")

          2. For each provider in kata.yaml reviews.code_reviewers (or reviews.code_reviewer
             if using the singular form), run one at a time:
          ```bash
          kata review --prompt=code-review --provider=<name>
          ```
          Read kata.yaml to find configured reviewers. Skip if reviews.code_review is false
          or no reviewers are configured.

          Print each result as it completes. All reviews must finish before marking complete.

  # Legacy pattern — kept for backwards compatibility with existing project templates
  impl-verify:
    description: "Implement then verify each spec phase"
    steps:
      - id_suffix: impl
        title_template: "IMPL - {task_summary}"
        todo_template: "Implement {task_summary}"
        active_form: "Implementing {phase_name}"
        labels: [impl]
        instruction: |
          ⛔ DO NOT implement this phase yourself. SPAWN an impl-agent.

          Task(subagent_type="impl-agent", prompt="
            SPEC PHASE: {phase_name}
            TASK: {task_summary}
            Do NOT complete tasks — return results to orchestrator.
          ")

          After the agent returns, verify its work:
          ```bash
          git diff --stat   # Review what changed
          git status        # Confirm changes exist
          ```

          Then: Mark this task completed via TaskUpdate
      - id_suffix: check
        title_template: "CHECK - {phase_name}"
        todo_template: "Check {phase_name} implementation"
        active_form: "Checking {phase_name}"
        labels: [check]
        depends_on_previous: true
        instruction: |
          If the spec phase has `test_cases:` and tests don't exist yet, spawn test-agent first:
          Task(subagent_type="test-agent", prompt="
            SPEC PHASE: {phase_name}
            Write tests for any spec test_cases not yet covered.
            Return: test files written, pass/fail results.
          ")

          Then run the process gate:
          kata check-phase {phase_label} --issue={issue}
